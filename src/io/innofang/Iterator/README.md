# Iterator (迭代器模式)

其实在平常的开发当中，迭代器模式是被经常使用的，举个例子，比如使用迭代器遍历结合
```java
/* 创建List容器*/
List<Integer> list = new ArrayList<>();
/* 添加数据*/
for (int i = 0; i < 100; i++) {
    list.add(i);
}
/* 迭代容器 */
Iterator<Integer> iterator = list.iterator();
while(iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

如此看来，开发者对于迭代器模式应该还是比较熟悉的，而迭代器的作用也的确如此 ———— 遍历一个容器对象。

下面来看一下迭代器模式UML的类图

## Iterator (迭代器模式)的UML类图

![](http://my.csdn.net/uploads/201204/02/1333348153_6748.jpg)

 + Aggregate : 容器接口
 + ConcreteAggregate : 具体容器类
 + Iterator : 迭代器接口
 + ConcreteIterator : 具体的迭代器接口

那么迭代器模式在一个自定义的容器中是如何使用的呢？、

我们在使用迭代器模式的时候，是先从容器中获得迭代器对象的，当获得迭代器对象后，在利用迭代器的 `hasNext()` 方法来判断是否有下一个元素，当结果为 `true` 时，再利用 `next()` 方法返回下一个数据，以此来达到遍历结合的目的

如果这一块不熟悉，可以看一下上面的例子来加深理解

## 迭代器模式的简单实现

来一个例子：如果假设现在图书馆新进了一批书，现在你需要遍历查找这些新进的书是否有自己想要的

当然，如果只是创建一个 `Book` 的实体类，然后再创建一个 `Book` 类型的 `List` 集合，然后遍历这个 `List` 集合，似乎问题并没有那么复杂，但是，在实际开发当中，事情往往没有那么简单

因为将书细分下来还有很多的分类类：文学类，科技类，编程类等，因此，如果只是将这些书用一个容器保存就欠妥了

那如果使用多个集合呢？似乎问题也能解决，但是在实际开发当中，往往是协同开发

举个例子，如果A的工作是建立图书的存储功能，B是建立图书的查询功能，那么这时B对A所建立的容器是不熟悉的，那么这时他该如何决定遍历容器的方式呢？

这就是问题所在，这时利用迭代器模式，A在自己的存储功能中，实现这种模式，并对外暴露迭代器创建的方法，然后，在自己这个容器内部实现具体的迭代细节，这样当B实现查询功能时，只需要用一套迭代器查询方法就可以了。

由此看出，迭代器模式的优点就是降低了容器与迭代算法的耦合

经过上述分析，那么就来简单实现一下这个案例吧，建立一个文学类书籍容器和编程类书籍容器，然后利用迭代器模式进行遍历

首先就是




